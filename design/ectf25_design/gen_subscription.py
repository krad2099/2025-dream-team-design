import argparse
import json
from pathlib import Path
import struct
import hashlib

def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription using MD5.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe.

    Instead of encrypting, we compute an MD5 digest of the subscription data.

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    :returns: 16-byte MD5 digest of the subscription data
    """
    # Load the JSON of the secrets file (though not used directly here)
    secrets = json.loads(secrets)

    # Pack the subscription data (device_id, start, end, channel)
    subscription_data = struct.pack("<IQQI", device_id, start, end, channel)
    
    # Compute the MD5 hash of the subscription data
    md5 = hashlib.md5()
    md5.update(subscription_data)
    digest = md5.digest()  # 16-byte MD5 hash

    return digest

def parse_args():
    """Define and parse the command line arguments

    NOTE: Your design must not change this function.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()

def main():
    """Main function of gen_subscription"""
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Print the generated subscription for debugging
    print(f"Generated subscription: {subscription}")

    # Write the subscription data to a file (overwriting if --force is specified)
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    print(f"Wrote subscription to {str(args.subscription_file.absolute())}")

if __name__ == "__main__":
    main()
